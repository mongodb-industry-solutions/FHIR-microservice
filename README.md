# How to create your own FHIR search microservice with MongoDB


MongoDB offers a range of Atlas App Services, that have extensive serverless backend capabilities. One such capability is Atlas data API, which allows you to create an endpoint for the read and write access in a specific cluster. You can enable authentication and customize the data access on the collections, based on the rules that you can define with the App Services Rules.

In this blog post, I’ll walk you through how you can expose the data of a FHIR compliant collection through Atlas Data API to two different users with different permissions.

Scenario :
Dataset: we have a simple dataset with FHIR compliant documents. These ressources, are varied: Patients, locations, and Practitioners.
We have two users that have different responsibilities:
The first one is hcprovider, he works on a specific location and should only have access to the appointments in said location.
The second is hcagency, he works in the healthcare agency, and analyzes the appointments from several centers. He should not be able to look at PII.

Prerequisites :
Provision an Atlas cluster (even the tier M0 should be enough for the feature to be tested). 
Having installed python3 along with pymongo and mimesis modules to insert documents.


##  1: Insert FHIR documents into the database

If you don't have a collection with FHIR compliant Appointments, then please clone this repository.

[Then go to our datasetScripts/localScripts folder and follow the instructions](https://github.com/mongodb-industry-solutions/FHIR-microservice/tree/main/datasetScripts/localScripts)

##  2: Create an App Services Application

[Setup MongoDB Atlas Backend](https://github.com/mongodb-industry-solutions/FHIR-microservice/tree/main/datasetScripts/serverlessFunctions)

##  3.1: Enable JWT-based authentication
Navigate to the homepage of the App Services application. Click Authentication on the left-hand side menu and click the EDIT button of the row where the provider is Custom JWT Authentication.
JWT (JSON Web Token)
 provides a token-based authentication where a token is generated by the client based on an agreed secret and cryptography algorithm. After the client transmits the token, the server validates the token with the agreed secret and cryptography algorithm and then processes client requests if the token is valid.
In the configuration options of the Custom JWT Authentication, fill out the options with the following:
- Enable the Authentication Provider (Provider Enabled must be turned on).
- Keep the verification method as is (Manually specify signing keys).
- Keep the signing algorithm as is (HS256).
- Add a new signing key.
 * Provide the signing key name.
  + For example, APITestJWTSigningKEY.
 * Provide the secure key content (between 32 and 512 characters) and note it somewhere secure.
  + For example, FipTEgYJ6WfUEhCJq3e@pm8-TkE9*UZN.
- Add two fields in the metadata fields.
 * The path should be metadata.group and the corresponding field should be group.
 * The path should be metadata.name and the corresponding field should be name.
- Keep the audience field as is (empty).
Below, you can find how the JWT Authentication Provider form has been filled accordingly.

![image](/Media/JWTAuthentication.png)

Save it and then Deploy it.
After it’s deployed, you can see the secret that has been created in the [App Services Values](https://www.mongodb.com/docs/atlas/app-services/values-and-secrets/), that can be accessible on the left side menu by clicking Values.

![image](/Media/Values.png)

## Step 3.2: Test JWT authentication
Now, we need an encoded JWT to pass it to App Services Data API to authenticate and consequently access the underlying data.
You can have a separate external authentication service that can provide a signed JWT that you can use in App Services Authentication. However, for the sake of simplicity, we’ll generate our own fake JWTs through [jwt.io](https://jwt.io/).
These are the steps to generate an encoded JWT:
 - Visit [jwt.io](https://jwt.io/).
 - On the right-hand side in the section Decoded, we can fill out the values. On the left-hand side, the corresponding Encoded JWT will be generated.
 - In the Decoded section:
  * Keep the Header section the same.
  * In the Payload section, set the following fields:
   + Sub.
     - Represents the owner of the token.
     - Provide value unique to the user.
   + Metadata.
     - Represents metadata information regarding this token and can be used for further processing in App Services.
     - We have two sub fields here.
      * Name.
       + Represents the username of the client that will initiate the API request.
       + This information will be used as the username in App Services.
      * Group.
       + Represents the group information of the client that we’ll use later for rule-based access.
  + Exp.
     - Represents when the token is going to expire.
     - Provide a future time to keep expiration impossible during our tests.
  + Aud.
     - Represents the name of the App Services Application that you can get from the homepage of your application in App Services.
  * In the Verify Signature section:
   + Provide the same secret that you’ve already provided while enabling [Custom JWT Authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/) in Step 3.1.

Below, you can find how the values have been filled out in the Decoded section and the corresponding Encoded JWT that has been generated.

![image](/Media/JWTio.png)

Copy the generated JWT from the Encoded section and pass it to the header section of the HTTP request, as shown below.

```curl
curl --request GET {{URL}} \  --header 'jwtTokenString: {{JWT}}' \  --header 'Content-Type: application/json'
```

```json
{"error": "no matching rule found" }
```

We get the following error: “no rule exists for namespace.” Basically, we were able to authenticate to the application. However, since there were no [App Services Rules](https://www.mongodb.com/docs/atlas/app-services/rules/) defined, we were not able to access any data.

Even though the request is not successful due to the no rule definition, you can check out the App Users page to list authenticated users as shown below. user01 was the name of the user that was provided in the metadata.name field of the JWT.

![image](/Media/AppUsers.png)

Side note: If you get an error like the one below, then please double check all JWT payload parameters, and that the value on the signature is indeed the same as the one in the JWT authentication in Atlas.

```json
{ "error": "invalid session: error finding user for endpoint", "error_code": "InvalidSession", "link": "https://realm.mongodb.com/groups/64e34f487860ee7a5c8fc990/apps/64e35fe30e434ffceaca4c89/logs?co_id=64e38620f6325153d3305085" }
```

## Step 4.1: Create a Role in App Services Rules

Roles are what determine what the user can and cannot see. By default, no one can see anything which is why we had the error above. However, here, we have the simple scenario where both users need access to the same collection, namely “appointments”. If you want to see how to configure Atlas so that we give access to different collections to each user, as well as some other details of Atlas’ app services RBAC please check out [this tutorial](https://www.mongodb.com/developer/products/atlas/rule-based-access-atlas-data-api/#steps-to-set-up).

Otherwise, Let’s create a role that will have access to all of the fields. This role will be for the users that are in Group 01.
 - Navigate the [Rules](https://www.mongodb.com/docs/atlas/app-services/rules/) section on the left-hand side of the menu in App Services.
 - Choose the collection appointments on the left side of the menu.
 - Click readAll on the right side of the menu, as shown below.

![image](/Media/Rules.png)

## Step 4.2: Create filters in App Services Rules

Let’s reiterate our scenario:
 - We have two users that have different responsibilities:
  - The first one is hcprovider, he works on a specific location and should only have access to the appointments in said location.
  - The second is hcagency, he works in the healthcare agency, and analyzes the appointments from several centers. He should not be able to look at PII.

We will configure two filters to account for this. Let’s start with the hc provider. Before, actually doing the actual configuration. We will need to set to which location the healthcare provider will be working. To do so, I just connected to the database with compass for example and chose a random location as below.

![image](/Media/LocationEx.png)

Now that we have the location of our hc provider let’s create the first filter:
 - Let’s navigate back to app services rules, and select the appointments collection just like before.
 - Now let’s select the filters tab around the center of the screen.
 - Click on add filter
  - Name it
  - Add “ { "%%user.data.group": "group01" } ” to the apply when prompt.
  - Add “ { "location.display": "St. Barney clinic" } ” to the query prompt.
  - Save and deploy

![image](/Media/FilterGroup1.png)

Let’s do the second user:
 - Click on add filter
 - Name it
  - Add “{ "%%user.data.group": "group02" }” to the apply when prompt.
  - Add the document below to the projection prompt.
  - Save and deploy

```json
{"_id": 1,
  "resourceType": 1,
  "status": 1,
  "created": 1,
  "start": 1,
  "description": 1,
  "serviceType": 1,
  "participant.actor.reference": 1,
  "participant.actor.required": 1,
  "participant.actor.status": 1,
  "location": 1}
```

![image](/Media/FilterGroup2.png)

Make sure to create a second JWT token for the hcagency with a different metadata.name, metadata.group and sub.

## Step 5: How to query on your Appointment FHIR search microservice

In order to fully understand all of the functionalities that this server should have, we will refer ourself to the FHIR documentation. As a demo, this won’t be presenting all of FHIR search capabilities. Instead, we will focus on the basic ones.

In our server we will be able to respond to 2 types of inputs. First the regular search parameters that we can see [at the bottom of the ressources’ page](http://hl7.org/fhir/appointment.html). And second, we will implement the [Search Result Parameters](http://hl7.org/fhir/search.html#modifyingresults) that can modify the results of a performed search. Because of our data schema, not all will apply hence, not all were coded into the function.

More precisely, we will be able to call the search parameters: actor, date, identifier, location, part-status, patient, practitioner, status. As well as the search result parameters: _count, _elements, _sort, _maxresults,_total, along with the page parameter. Please refer to the [FHIR documentation](http://hl7.org/fhir/search.html#modifyingresults) to see how they work. 

Make sure to test both users as the results here you have a couple of examples (to keep it short I’ll set the page to a single appointment.

hcprovider:

```curl
curl --request GET '{{URL}}?_count=1' \  --header 'jwtTokenString: {{hcproviderJWT}}' \  --header 'Content-Type: application/json'
```

HTTP/1.1 200 OK
content-encoding: gzip
content-type: application/json
strict-transport-security: max-age=31536000; includeSubdomains;
vary: Origin
x-appservices-request-id: 64e5e47e6dbb75dc6700e42c
x-frame-options: DENY
date: Wed, 23 Aug 2023 10:50:38 GMT
content-length: 671
x-envoy-upstream-service-time: 104
server: mdbws
x-envoy-decorator-operation: baas-main.baas-prod.svc.cluster.local:8086/*
connection: close

```json
{"resourceType": "Bundle","type": "searchset","total": 384,"link": [{"relation": "self","url": "https://fakeurl.com/endpoint/Appointment"},{"relation": "next","url": "https://fakeurl.com/endpoint/Appointment?page=2\u0026_count=1"}],"entry": [{"fullUrl": "https://fakeurl.com/endpoint/Appointment?id=64e35896eaf6edfdbe5f22be","resource": {"_id": "64e35896eaf6edfdbe5f22be","resourceType": "Appointment","status": "proposed","created": "2023-08-21T14:29:10.312Z","start": "2023-08-21T14:29:09.535Z","description": "Breast Mammography Screening","serviceType": [{"coding": [{"system": "http://snomed.info/sct","code": "278110001","display": "radiographic imaging"}],"text": "Mammography"}],"participant": [{"actor": {"reference": "64e354874f5c09af1a8fc2b6","display": [{"given": ["Marta"],"family": "Donovan"}]},"required": true,"status": "needs-action"},{"actor": {"reference": "64e353d80727df4ed8d00839","display": [{"use": "official","family": "Harrell","given": ["Juan Carlos"]}]},"required": true,"status": "accepted"}],"location": {"reference": "64e35380f2f2059b24dafa60","display": "St. Barney clinic"}},"search": {"mode": "match"}}]}
```

hcagency:

```curl
curl --request GET '{{URL}}?_count=1' \  --header 'jwtTokenString: {{hcagencyJWT}}' \  --header 'Content-Type: application/json'\
```

HTTP/1.1 200 OK
content-encoding: gzip
content-type: application/json
strict-transport-security: max-age=31536000; includeSubdomains;
vary: Origin
x-appservices-request-id: 64e5e4eee069ab6f307d792e
x-frame-options: DENY
date: Wed, 23 Aug 2023 10:52:30 GMT
content-length: 671
x-envoy-upstream-service-time: 162
server: mdbws
x-envoy-decorator-operation: baas-main.baas-prod.svc.cluster.local:8086/*
connection: close

```json
{"resourceType": "Bundle","type": "searchset","total": 6720,"link": [{"relation": "self","url": "https://fakeurl.com/endpoint/Appointment"},{"relation": "next","url": "https://fakeurl.com/endpoint/Appointment?page=2\u0026_count=1"}],"entry": [{"fullUrl": "https://fakeurl.com/endpoint/Appointment?id=64e35896eaf6edfdbe5f22be","resource": {"_id": "64e35896eaf6edfdbe5f22be","resourceType": "Appointment","status": "proposed","created": "2023-08-21T14:29:10.312Z","start": "2023-08-21T14:29:09.535Z","description": "Breast Mammography Screening","serviceType": [{"coding": [{"system": "http://snomed.info/sct","code": "278110001","display": "radiographic imaging"}],"text": "Mammography"}],"participant": [{"actor": {"reference": "64e354874f5c09af1a8fc2b6","display": [{"given": ["Marta"],"family": "Donovan"}]},"required": true,"status": "needs-action"},{"actor": {"reference": "64e353d80727df4ed8d00839","display": [{"use": "official","family": "Harrell","given": ["Juan Carlos"]}]},"required": true,"status": "accepted"}],"location": {"reference": "64e35380f2f2059b24dafa60","display": "St. Barney clinic"}},"search": {"mode": "match"}}]}
```

Please note the difference on the total number of documents fetched as well as the participant.actor.display fields missing for the agency user.


## Step 6: How to call the micro-service from an application

The calls that were shown up to this point were from API platforms such as Postman, or Visual Studio’s REST client. However, for security reasons when putting this into an application such as a React.js application, then the calls might be getting blocked by the CORS policy. To avoid this we need to authenticate our data API request. You can read more on how to manage your user sessions [here](https://www.mongodb.com/docs/atlas/app-services/users/sessions/#std-label-manage-user-sessions). But for us it should be as simple as sending the following request:

```curl
curl -X POST 'https://<Region>.<Cloud>.realm.mongodb.com/api/client/v2.0/app/<AppID>/auth/providers/custom-token/login' \
  --header 'Content-Type: application/json' \
  --data-raw '{
          "token": "<JWT token>"
  }'
```

This will return something like:

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJiYWFzX2RldmljZV9pZCI6Ij{...}jNkYjdmOSIsInR5cCI6ImFjY2VzcyJ9.pyq3nfzFUT-6r-umqGrEVIP8XHOw0WGnTZ3-EbvgbF0",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJiYWFzX2RhdGEiOm51bGwsI{...}mJhYXNfZGV2aWNlX2lkIjoiMlc2gifQ.h9YskmSpSLK8DMwBpPGuk7g1s4OWZDifZ1fmOJgSygw",
  "user_id": "636aba021728b6c1c03db7f9"
}
```

These token will allow your application to request data from your FHIR microservice. You will just need to replace the header  'jwtTokenString: {{JWT}}' with 'Authorization: Bearer {{token above}}'. Like so:

```curl
curl --request GET {{URL}} \  --header 'Authorization: Bearer {{token above}}' \ 
--header 'Content-Type: application/json'
```

```json
{"error": "no matching rule found" }
```

You can find additional information on how to authenticate Data API requests [here](https://www.mongodb.com/docs/atlas/app-services/data-api/authenticate/#bearer-authentication).


## Summary

MongoDB Atlas App Services offers a robust platform for building your serverless backend with unparalleled ease. In this tutorial, we've explored how to:  
Generate your own FHIR data
To configure serverless functions along with Custom JWT Authentication to seamlessly integrate user-specific information. 
Implement precise data access control through roles and filters. 
And how to call the configured APIs directly from the code

Are you ready to dive in and leverage these capabilities for your projects? Don't miss out on the chance to explore the full potential of MongoDB Atlas App Services. Get started with a free trial by provisioning an M0 Atlas instance and creating your own App Services Application. 
Should you encounter any roadblocks or have questions, our vibrant [developer forums](https://www.mongodb.com/community/forums/) are here to support you every step of the way.  
